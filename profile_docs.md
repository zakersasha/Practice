# Code profiling

Модули профилирования предназначены для предоставления ресурсных затрат выполнения программы. Включает в себя проверку затрачиваемой памяти и выделенного времени на каждой строке кода.

# Memory Profiler

### 1. Установка и импорт

```
pip install memory-profiler
```

```
from memory_profiler import profile
```

### 2. Использование

- На профилируемую функцию устанавливается декоратор

```
@profile
def my_func():
```

### 3. Получение результатов

- При тестировании в рамках отдельного скрипта

```
@profile
def my_func():
    ...
    
if __name__ == '__main__':
    my_func()
```

```
python -m memory_profiler example.py
```

- При тестировании в рамках работы сервиса результат будет выведен в консоль/терминал

### 4. Ожидаемый результат

```
Line    Mem usage    Increment  Occurrences   Line Contents
============================================================
     3   38.816 MiB   38.816 MiB           1   @profile
     4                                         def my_func():
     5   46.492 MiB    7.676 MiB           1       a = [1] * (10 ** 6)
     6  199.117 MiB  152.625 MiB           1       b = [2] * (2 * 10 ** 7)
     7   46.629 MiB -152.488 MiB           1       del b
     8   46.629 MiB    0.000 MiB           1       return a
```

- Line : номер строки
- Mem usage : использование памяти интерпретатором Python после выполнения этой строки
- Increment : представляет разницу в памяти текущей строки по отношению к последней
- Line Contents : печатает код, который был профилирован

---

# Time Profiler

### 1. Установка и импорт

```
pip install line_profiler
```

```
from line_profiler import LineProfiler
```

### 2. Использование

- Создается экземпляр

```
profiler = LineProfiler()
```

- Создается функция-декоратор
```
def profile(func)
    def inner(*args, **kwargs)
        profiler.add_function(func)
        profiler.enable_by_count()
        return func(*args, **kwargs)
    return inner
 ```   

- Создается функция для вывода статистики
 ```   
def print_stats():
    profiler.print_stats()
```

### 3. Получение результатов

- Устанавливаем декоратор над тестируемой функцией и вызываем функцию вывода статистики

```
@profile
def my_func():
    ...
    print_stats()
```
### 4. Ожидаемый результат

```
Line #      Hits       Time   Per Hit      % Time   Line Contents
=================================================================
105         1         4.0       4.0          0.5    @profile
106         1001      360.0     0.4          47.4   def a():
107         1000      396.0     0.4          52.1       b = 1
108                                                     for i in range(1000):
109                                                         b += i
                                                        print_states()
                                                        return b
```

- Line : номер строки
- Hits : количество запусков строки
- Time : общее количество времени, в течение которого эта строка выполнялась для всех обращений
- Per Hit: среднее количество времени (Time / Hits)
- % Time: процент времени, затраченного на эту строку, по отношению к общему количеству записанного времени, проведенного в функции
- Line Contents : печатает код, который был профилирован

---